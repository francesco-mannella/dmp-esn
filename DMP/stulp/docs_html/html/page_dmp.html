<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>DMP_BBO library: Dynamical Movement Primitives Module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">DMP_BBO library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Dynamical Movement Primitives Module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_dmp_introduction"></a>
Introduction</h1>
<p>The core idea behind dynamical movement primitives (DMPs) is to represent movement primitives as a combination of dynamical systems (please read <a class="el" href="page_dyn_sys.html">Dynamical Systems Module</a>, if you haven't already done so). The state variables of the main dynamical system <img class="formulaInl" alt="$ [\mathbf{y \dot{y} \ddot{y}} ]$" src="form_2.png"/> then represent trajectories for controlling, for instance, the 7 joints of a robot arm, or its 3D end-effector position. The attractor state is the end-point or <em>goal</em> of the movement.</p>
<p>The key advantage of DMPs is that they inherit the nice properties from linear dynamical systems (guaranteed convergence towards the attractor, robustness to perturbations, independence of time, etc) whilst allowing arbitrary (smooth) motions to be represented by adding a non-linear forcing term. This forcing term is often learned from demonstration, and subsequently improved through reinforcement learning.</p>
<p>DMPs were introduced in <b>[ijspeert02movement]</b>, but in this section we follow largely the notation and description in <b>[ijspeert13dynamical]</b>, but at a slower pace.</p>
<p><em>Historical</em> <em>remark</em>. Recently, the term "dynamicAL movement primitives" is preferred over "dynamic movement primitives". The newer term makes the relation to dynamicAL systems more clear, and avoids confusion about whether the output of "dynamical movement primitives" is in kinematic or dynamic space (it is usually in kinematic space).</p>
<p><em>Remark</em>. This documentation and code focusses only on discrete movement primitives. For rythmic movement primitives, we refer to <b>[ijspeert13dynamical.]</b></p>
<h1><a class="anchor" id="sec_core"></a>
Basic Point-to-Point Movements: A Critically Damped Spring-Damper System</h1>
<p>At the heart of the DMP lies a spring-damper system, as described in <a class="el" href="page_dyn_sys.html#dyn_sys_spring_damper">Spring-Damper Systems</a>. In DMP papers, the notation of the spring-damper system is usually a bit different: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} m\ddot{y} =&amp; -ky -c\dot{y} &amp; \mbox{spring-damper system, ``traditional notation''} \\ m\ddot{y} =&amp; c(-\frac{k}{c}y - \dot{y})\\ \tau\ddot{y} =&amp; \alpha(-\beta y - \dot{y}) &amp; \mbox{with } \alpha=c,~~\beta = \frac{k}{c},~~m=\tau\\ \tau\ddot{y} =&amp; \alpha(-\beta (y-y^g) - \dot{y})&amp; \mbox{with attractor } y^g\\ \tau\ddot{y} =&amp; \alpha(\beta (y^g-y) - \dot{y})&amp; \mbox{typical DMP notation for spring-damper system}\\ \end{eqnarray*}" src="form_3.png"/>
</p>
<p>In the last two steps, we change the attractor state from 0 to <img class="formulaInl" alt="$y^g$" src="form_4.png"/>, where <img class="formulaInl" alt="$y^g$" src="form_4.png"/> is the goal of the movement.</p>
<p>To avoid overshooting or slow convergence towards <img class="formulaInl" alt="$y^g$" src="form_4.png"/>, we prefer to have a <em>critically</em> <em>damped</em> spring-damper system for the DMP. For such systems <img class="formulaInl" alt="$c = 2\sqrt{mk}$" src="form_5.png"/> must hold, see <a class="el" href="page_dyn_sys.html#dyn_sys_critical_damping">Critical Damping</a>. In our notation this becomes <img class="formulaInl" alt="$\alpha = 2\sqrt{\alpha\beta}$" src="form_6.png"/>, which leads to <img class="formulaInl" alt="$\beta = \alpha/4$" src="form_7.png"/>. This determines the value of <img class="formulaInl" alt="$\beta$" src="form_8.png"/> for a given value of <img class="formulaInl" alt="$\alpha$" src="form_9.png"/> in DMPs. The influence of <img class="formulaInl" alt="$\alpha$" src="form_9.png"/> is illustrated in the first figure in <a class="el" href="page_dyn_sys.html#sec_dyn_sys_intro">Introduction</a>.</p>
<p>Rewriting the second order dynamical system as a first order system (see <a class="el" href="page_dyn_sys.html#dyn_sys_rewrite_second_first">Rewriting one 2nd Order Systems as two 1st Order Systems</a>) with expanded state <img class="formulaInl" alt="$ [z~y]$" src="form_10.png"/> yields:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{z}} \\ {\dot{y}} \end{array} \right] = \left[ \begin{array}{l} (\alpha (\beta({y}^{g}-{y})-{z}))/\tau \\ {z}/\tau \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} 0 \\ y_0 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} {0} \\ {y}^g \end{array} \right] \end{eqnarray*}" src="form_11.png"/>
</p>
<p>Please note that in the implementation, the state is implemented as <img class="formulaInl" alt="$ [y~z]$" src="form_12.png"/>. The order is inconsequential, but we use the notation above ( <img class="formulaInl" alt="$[z~y]$" src="form_13.png"/>) throughout the rest of this tutorial section, for consistency with the DMP literature.</p>
<h1><a class="anchor" id="sec_forcing"></a>
Arbitrary Smooth Movements: the Forcing Term</h1>
<p>The representation described in the previous section has some nice properties in terms of <a class="el" href="page_dyn_sys.html#sec_dyn_sys_convergence">Convergence towards the Attractor</a> , <a class="el" href="page_dyn_sys.html#sec_dyn_sys_perturbations">Robustness to Perturbations</a> , and <a class="el" href="page_dyn_sys.html#sec_dyn_sys_autonomy">Autonomy</a>, but it can only represent very simple movements. To achieve more complex movements, we add a time-dependent forcing term to the spring-damper system. The spring-damper systems and forcing term are together known as a <em>transformation</em> <em>system</em>.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{z}} \\ {\dot{y}} \end{array} \right] = \left[ \begin{array}{l} (\alpha (\beta({y}^{g}-{y})-{z}) + f(t))/\tau \\ {z}/\tau \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} 0 \\ y_0 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} {?} \\ {y}^g \end{array} \right] \end{eqnarray*}" src="form_14.png"/>
</p>
<p>The forcing term is an open loop controller, i.e. it depends only on time. By modifying the acceleration profile of the movement with a forcing term, arbitrary smooth movements can be achieved. The function <img class="formulaInl" alt="$ f(t)$" src="form_15.png"/> is usually a function approximator, such as locally weighted regression (LWR) or locally weighted projection regression (LWPR), see <a class="el" href="page_func_approx.html">Function Approximation Module</a>. The graph below shows an example of a forcing term implemented with LWR with random weights for the basis functions.</p>
<div class="image">
<img src="dmp_forcing_terms-svg.png" alt="dmp_forcing_terms-svg.png"/>
<div class="caption">
A non-linear forcing term enable more complex trajectories to be generated (these DMPs use a goal system and an exponential gating term).</div></div>
<h2><a class="anchor" id="sec_forcing_convergence"></a>
Ensuring Convergence to 0 of the Forcing Term: the Gating System</h2>
<p>Since we add a forcing term to the dynamical system, we can no longer guarantee that the system will converge towards <img class="formulaInl" alt="$ x^g $" src="form_16.png"/>; perhaps the forcing term continually pushes it away <img class="formulaInl" alt="$ x^g $" src="form_16.png"/> (perhaps it doesn't, but the point is that we cannot <em>guarantee</em> that it <em>always</em> doesn't). That is why there is a question mark in the attractor state in the equation above. To guarantee that the movement will always converge towards the attractor <img class="formulaInl" alt="$ x^g $" src="form_16.png"/>, we need to ensure that the forcing term decreases to 0 towards the end of the movement. To do so, a gating term is added, which is 1 at the beginning of the movement, and 0 at the end. This gating term itself is determined by, of course, a dynamical system. In <b>[ijspeert02movement]</b>, it was suggested to use an exponential system. We add this extra system to our dynamical system by expanding the state as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot{x} = \left[ \begin{array}{l} {\dot{z}} \\ {\dot{y}} \\ {\dot{x}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({y}^{g}-{y})-{z}) + x\cdot f(t))/\tau \\ {z}/\tau \\ -\alpha_x x/\tau \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} 0 \\ y_0 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} {0} \\ {y}^g \\ 0 \end{array} \right] \end{eqnarray*}" src="form_17.png"/>
</p>
<h2><a class="anchor" id="sec_forcing_autonomy"></a>
Ensuring Autonomy of the Forcing Term: the Phase System</h2>
<p>By introducing the dependence of the forcing term <img class="formulaInl" alt="$ f(t)$" src="form_15.png"/> on time <img class="formulaInl" alt="$ t $" src="form_18.png"/> the overall system is no longer autonomous. To achieve independence of time, we therefore let <img class="formulaInl" alt="$ f $" src="form_19.png"/> be a function of the state of an (autonomous) dynamical system rather than of <img class="formulaInl" alt="$ t $" src="form_18.png"/>. This system represents the <em>phase</em> of the movement. <b>[ijspeert02movement]</b> suggested to use the same dynamical system for the gating and phase, and use the term <em>canonical</em> <em>system</em> to refer this joint gating/phase system. Thus the phase of the movement starts at 1, and converges to 0 towards the end of the movement, just like the gating system. The new formulation now is (the only difference is <img class="formulaInl" alt="$ f(x)$" src="form_20.png"/> instead of <img class="formulaInl" alt="$ f(t)$" src="form_15.png"/>):</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{z}} \\ {\dot{y}} \\ {\dot{x}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({y}^{g}-{y})-{z}) + x\cdot f(x))/\tau \\ {z}/\tau \\ -\alpha_x x/\tau \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} 0 \\ y_0 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} {0} \\ {y}^g \\ 0 \end{array} \right] \end{eqnarray*}" src="form_21.png"/>
</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Discuss goal-dependent scaling, i.e. <img class="formulaInl" alt="$ f(t)s(x^g-x_0) $" src="form_22.png"/>?</dd></dl>
<h2><a class="anchor" id="sec_multidim_dmp"></a>
Multi-dimensional Dynamic Movement Primitives</h2>
<p>Since DMPs usually have multi-dimensional states (e.g. one output <img class="formulaInl" alt="$ {\mathbf{y}}_{d=1\dots D}$" src="form_23.png"/> for each of the <img class="formulaInl" alt="$ D $" src="form_24.png"/> joints), it is more accurate to use bold fonts for the state variables (except the gating/phase system, because it is always 1D) so that they represent vectors:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{\mathbf{z}}} \\ {\dot{\mathbf{y}}} \\ {\dot{x}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({\mathbf{y}}^{g}-\mathbf{y})-\mathbf{z}) + x\cdot f(x))/\tau \\ \mathbf{z}/\tau \\ -\alpha_x x/\tau \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{z}_0 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}^g \\ 0 \end{array} \right] \end{eqnarray*}" src="form_25.png"/>
</p>
<p>So far, the graphs have shown 1-dimensional systems. To generate D-dimensional trajectories for, for instance, the 7 joints of an arm or the 3D position of its end-effector, we simply use D transformation systems. A key principle in DMPs is to use one and the same phase system for all of the transformation systems, to ensure that the output of the transformation systems are synchronized in time. The image below show the evolution of all the dynamical systems involved in integrating a multi-dimensional DMP.</p>
<div class="image">
<img src="dmpplot_ijspeert2002movement-svg.png" alt="dmpplot_ijspeert2002movement-svg.png"/>
<div class="caption">
The various dynamical systems and forcing terms in multi-dimensional DMPs.</div></div>
<p><em></em></p>
<p><em></em></p>
<h2><a class="anchor" id="Implementation"></a>
Implementation</h2>
<p><em> Since a Dynamical Movement Primitive is a dynamical system, the Dmp class derives from the DynamicalSystem class. It overrides the virtual function DynamicalSystem::integrateStart(). Integrating the DMP numerically (Euler or 4th order Runge-Kutta) is done with the generic DynamicalSystem::integrateStep() function. It also implements the pure virtual function DynamicalSystem::analyticalSolution(). Because a DMP cannot be solved analytically (we cannot write it in closed form due to the arbitrary forcing term), calling Dmp::analyticalSolution() in fact performs a numerical Euler integration (although the linear subsystems (phase, gating, etc.) are analytically solved because this is faster computationally).</em></p>
<p><em>Please note that in this tutorial we have used the notation <img class="formulaInl" alt="$[z~y]$" src="form_13.png"/> for consistency with the DMP literature. In the C++ implementation, the order is rather <img class="formulaInl" alt="$[y~z]$" src="form_26.png"/>.</em></p>
<p><em><em>Remark</em>. Dmp inherits the function DynamicalSystem::integrateStep() from the DynamicalSystem class. DynamicalSystem::integrateStep() uses either Euler integration, or 4-th order Runge-Kutta. The latter is more accurate, but requires 4 calls of DynamicalSystem::differentialEquation() instead of 1). Which one is used can be set with DynamicalSystem::set_integration_method(). To numerically integrate a dynamical system, one must carefully choose the integration time dt. Choosing it too low leads to inaccurate integration, and the numerical integration will diverge from the 'true' solution acquired through analytical solution. See <a href="http://en.wikipedia.org/wiki/Euler%27s_method">http://en.wikipedia.org/wiki/Euler%27s_method</a> for examples. Choosing dt depends entirely on the time-scale (seconds vs. years) and parameters of the dynamical system (time constant, decay parameters). For DMPs, which are expected to take between 0.5-10 seconds, dt is usually chosen to be in the range 0.01-0.001. </em></p>
<h1><a class="anchor" id="sec_dmp_alternative"></a>
Alternative Systems for Gating, Phase and Goals</h1>
<h2><a class="anchor" id="sec_dmp_sigmoid_gating"></a>
Gating: Sigmoid System</h2>
<p>A disadvantage of using an exponential system as a gating term is that the gating decreases very quickly in the beginning. Thus, the output of the function approximator <img class="formulaInl" alt="$ f(x) $" src="form_27.png"/> needs to be very high towards the end of the movement if it is to have any effect at all. This leads to scaling issues when training the function approximator.</p>
<p>Therefore, sigmoid systems have more recently been proposed <b>[kulvicius12joining]</b> as a gating system. This leads to the following DMP formulation (since the gating and phase system are no longer shared, we introduce a new state variable <img class="formulaInl" alt="$ v $" src="form_28.png"/> for the gating term:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{\mathbf{z}}} \\ {\dot{\mathbf{y}}} \\ {\dot{x}} \\ {\dot{v}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({\mathbf{y}}^{g}-\mathbf{y})-\mathbf{z}) + v\cdot f(x))/\tau \\ \mathbf{z}/\tau \\ -\alpha_x x/\tau \\ -\alpha_v v (1-v/v_{\mbox{\scriptsize max}}) \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}_0 \\ 1 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}^g \\ 0 \\ 0 \end{array} \right] \end{eqnarray*}" src="form_29.png"/>
</p>
<p>where the term <img class="formulaInl" alt="$ v_{\mbox{\scriptsize max}}$" src="form_30.png"/> is determined by <img class="formulaInl" alt="$\tau $" src="form_31.png"/></p>
<h2><a class="anchor" id="sec_dmp_phase"></a>
Phase: Constant Velocity System</h2>
<p>In practice, using an exponential phase system may complicate imitation learning of the function approximator <img class="formulaInl" alt="$ f $" src="form_19.png"/>, because samples are not equidistantly spaced in time. Therefore, we introduce a dynamical system that mimics the properties of the phase system described in <b>[kulvicius12joining]</b>, whilst allowing for a more natural integration in the DMP formulation, and thus our code base. This system starts at 0, and has a constant velocity of <img class="formulaInl" alt="$1/\tau$" src="form_32.png"/>, which means the system reaches 1 when <img class="formulaInl" alt="$t=\tau$" src="form_33.png"/>. When this point is reached, the velocity is set to 0.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \dot{x} =&amp; 1/\tau \mbox{~if~} x < 1 &amp; \\ &amp; 0 \mbox{~if~} x>1 \\ \end{eqnarray*}" src="form_34.png"/>
</p>
<p>This, in all honesty, is a bit of a hack, because it leads to a non-smooth acceleration profile. However, its properties as an input to the function approximator are so advantageous that we have designed it in this way (the implementation of this system is in the TimeSystem class).</p>
<div class="image">
<img src="phase_systems-svg.png" alt="phase_systems-svg.png"/>
<div class="caption">
Exponential and constant velocity dynamical systems as the 1D phase for a dynamical movement primitive.</div></div>
<p>With the constant velocity dynamical system the DMP formulation becomes:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{\mathbf{z}}} \\ {\dot{\mathbf{y}}} \\ {\dot{x}} \\ {\dot{v}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({\mathbf{y}}^{g}-\mathbf{y})-\mathbf{z}) + v\cdot f(x))/\tau \\ \mathbf{z}/\tau \\ 1/\tau \\ -\alpha_v v (1-v/v_{\mbox{\scriptsize max}}) \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}_0 \\ 0 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}^g \\ 1 \\ 0 \end{array} \right] \end{eqnarray*}" src="form_35.png"/>
</p>
<h2><a class="anchor" id="sec_delayed_goal"></a>
Zero Initial Accelerations: the Delayed Goal System</h2>
<p>Since the spring-damper system leads to high initial accelerations (see the graph to the right below), which is usually not desirable for robots, it was suggested to move the attractor of the system from the initial state <img class="formulaInl" alt="$ y_0 $" src="form_36.png"/> to the goal state <img class="formulaInl" alt="$ y^g $" src="form_37.png"/> <em>during</em> the movement <b>[kulvicius12joining.]</b> This delayed goal attractor <img class="formulaInl" alt="$ y^{g_d} $" src="form_38.png"/> itself is represented as an exponential dynamical system that starts at <img class="formulaInl" alt="$ y_0 $" src="form_36.png"/>, and converges to <img class="formulaInl" alt="$ y^g $" src="form_37.png"/> (in early versions of DMPs, there was no delayed goal system, and <img class="formulaInl" alt="$ y^{g_d} $" src="form_38.png"/> was simply equal to <img class="formulaInl" alt="$ y^g $" src="form_37.png"/> throughout the movement). The combination of these two systems, listed below, leads to a movement that starts and ends with 0 velocities and accelerations, and approximately has a bell-shaped velocity profile. This representation is thus well suited to generating human-like point-to-point movements, which have similar properties.</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \left[ \begin{array}{l} {\dot{\mathbf{z}}} \\ {\dot{\mathbf{y}}} \\ {\dot{\mathbf{y}}^{g_d}} \\ {\dot{x}} \\ {\dot{v}} \end{array} \right] = \left[ \begin{array}{l} (\alpha_y (\beta_y({\mathbf{y}}^{g_d}-\mathbf{y})-\mathbf{z}) + v\cdot f(x))/\tau \\ \mathbf{z}/\tau \\ -\alpha_g({\mathbf{y}^g-\mathbf{y}^{g_d}}) \\ 1/\tau \\ -\alpha_v v (1-v/v_{\mbox{\scriptsize max}}) \end{array} \right] \mbox{~~~~with init. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}_0 \\ \mathbf{y}_0 \\ 0 \\ 1 \end{array} \right] \mbox{~and attr. state~} \left[ \begin{array}{l} \mathbf{0} \\ \mathbf{y}^g \\ \mathbf{y}^g \\ 1 \\ 0 \end{array} \right] \end{eqnarray*}" src="form_39.png"/>
</p>
<div class="image">
<img src="dmp_and_goal_system-svg.png" alt="dmp_and_goal_system-svg.png"/>
<div class="caption">
A first dynamical movement primitive, with and without a delayed goal system (left: state variable, center: velocities, right: accelerations.</div></div>
<p>In my experience, this DMP formulation is the best for learning human-like point-to-point movements (bell-shaped velocity profile, approximately zero velocities and accelerations at beginning and start of the movement), and generates nice normalized data for the function approximator without scaling issues (an exact empirical evaluation is on the stack...). The image below shows the interactions between the spring-damper system, delayed goal system, phase system and gating system.</p>
<div class="image">
<img src="dmpplot_kulvicius2012joining-svg.png" alt="dmpplot_kulvicius2012joining-svg.png"/>
<div class="caption">
The various dynamical systems and forcing terms in multi-dimensional DMPs.</div></div>
<h1><a class="anchor" id="sec_dmp_issues"></a>
Known Issues</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>Known Issues</dd></dl>
<ul>
<li>Scaling towards novel goals</li>
</ul>
<h1><a class="anchor" id="sec_dmp_summary"></a>
Summary</h1>
<p>The core idea in dynamical movement primitives is to combine dynamical systems, which have nice properties in terms of convergence towards the goal, robustness to perturbations, and independence of time, with function approximators, which allow for the generation of arbitrary (smooth) trajectories. The key enabler to this approach is to gate the output of the function approximator with a gating system, which is 1 at the beginning of the movement, and 0 towards the end.</p>
<p>Further enhancements can be made by making the system autonomous (by using the output of a phase system rather than time as an input to the function approximator), or having initial velocities and accelerations of 0 (by using a delayed goal system).</p>
<p>Multi-dimensional DMPs are achieved by using multi-dimensional dynamical systems, and learning one function approximator for each dimension. Synchronization of the different dimensions is ensure by coupling them with only <em>one</em> phase system. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 9 2016 10:16:52 for DMP_BBO library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
